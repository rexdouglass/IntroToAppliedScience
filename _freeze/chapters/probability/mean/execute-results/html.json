{
  "hash": "7d7999c9ca309a2b757e7f57b2cd99ad",
  "result": {
    "markdown": "# Mean  {.unnumbered}\n\n## Introduction\n\n**Measure of**: Central tendency\n\n## Frequentist\n\n**AKA**: Arithmetic mean; average; $\\bar{x}$ (sample mean); $\\mu$ (population mean); $\\mu_x$ (population mean)\n\n**Distinct from**: Geometric mean (GM); Harmonic mean (HM); generalized mean/ Power mean; weighted arithmetic mean\n\n**English**: Take a list of numbers, sum those numbers, and then divide by the number of numbers.  \n\n**Formalization**:\n\n\n\n$$ \n\\bar{x}=\\frac{1}{n}(\\sum^{n}_{i=1}x_i)=\\frac{x_1+x_2+...+x_n}{n} \n$$\n\n\n**Cites**: [Wikipedia](https://en.wikipedia.org/wiki/Mean) ; [Wikidata](https://www.wikidata.org/wiki/Q2796622) ; [Wolfram](https://mathworld.wolfram.com/ArithmeticMean.html)\n\n**Code**\n\n::: panel-tabset\n\n### R\n\n**Documentation**: [mean: Arithmetic Mean](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/mean)\n\nExamples:\n\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-1_99bccdd1f850ea641387488f41bd4d2e'}\n\n```{.r .cell-code}\nx = c(1,2,3,4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\n#Algorithm\nx_bar = sum(x, na.rm=T)/length(x)\nx_bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n\n```{.r .cell-code}\n#Base Function\nx_bar = mean(x, na.rm=T)\nx_bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n:::\n\n\n\n\n\n### Python\n\n**Documentation**: [numpy.mean](https://numpy.org/doc/stable/reference/generated/numpy.mean.html)\n\nExamples:\n\n\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-2_58bb25773f59e0100a0526116f99fbb8'}\n\n```{.python .cell-code}\nx = [1,2,3,4]\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4]\n```\n:::\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-3_9c685938e35f9a94f0210bad7210a1f7'}\n\n```{.python .cell-code}\n#Algorithm\nx_bar= sum(x)/len(x)\nx_bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.5\n```\n:::\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-4_9544199912c1e15401821fc0e2aa0d87'}\n\n```{.python .cell-code}\n#statistics Function\nimport statistics\nx_bar = statistics.mean(x)\nx_bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.5\n```\n:::\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-5_e414d6286bdfeefd229fe52dfeed2fef'}\n\n```{.python .cell-code}\n#scipy Function\n#<string>:1: DeprecationWarning: scipy.mean is deprecated and will be removed in SciPy 2.0.0, use numpy.mean instead\nimport scipy\nx_bar = scipy.mean(x) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<string>:1: DeprecationWarning: scipy.mean is deprecated and will be removed in SciPy 2.0.0, use numpy.mean instead\n```\n:::\n\n```{.python .cell-code}\nx_bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.5\n```\n:::\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-6_315b798fa5b4dbb27c4328d36895d713'}\n\n```{.python .cell-code}\n#numpy Function\nimport numpy as np\nx = np.array(x)\nx_bar = x.mean()\nx_bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.5\n```\n:::\n:::\n\n\n### SQL\n\n**Documentation**: [PostgreSQL AVG Function](https://www.postgresqltutorial.com/postgresql-aggregate-functions/postgresql-avg-function/)\n\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-7_4c6fed1806b8057e01fcdd9e69ec2f86'}\n\n```{.r .cell-code}\nlibrary(DBI)\n# Create an ephemeral in-memory RSQLite database\n#con <- dbConnect(RSQLite::SQLite(), dbname = \":memory:\")\n#dbListTables(con)\n#dbWriteTable(con, \"mtcars\", mtcars)\n#dbListTables(con)\n\n#Configuration failed because libpq was not found. Try installing:\n#* deb: libpq-dev libssl-dev (Debian, Ubuntu, etc)\n#install.packages('RPostgres')\n#remotes::install_github(\"r-dbi/RPostgres\")\n#Took forever because my file permissions were broken\n#pg_lsclusters\nrequire(RPostgres)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: RPostgres\n```\n:::\n\n```{.r .cell-code}\n# Connect to the default postgres database\n#I had to follow these instructions and create both a username and database that matched my ubuntu name\n#https://www.digitalocean.com/community/tutorials/how-to-install-postgresql-on-ubuntu-20-04-quickstart\ncon <- dbConnect(RPostgres::Postgres())\n```\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-8_e5d94ceb712efb00152172d9f9b5d043'}\n\n```{.sql .cell-code}\n\nDROP TABLE IF EXISTS t1;\n\n```\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-9_9034285f18da28355024e6fe4a4088d7'}\n\n```{.sql .cell-code}\n\nCREATE TABLE IF NOT EXISTS t1 (\n\tid serial PRIMARY KEY,\n\tamount INTEGER\n);\n\n```\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-10_9bb352a490d012a85143da163289644e'}\n\n```{.sql .cell-code}\nINSERT INTO t1 (amount)\nVALUES\n\t(10),\n\t(NULL),\n\t(30);\n```\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-11_805e5ecdeb5e30b1bf5e6c2a01dc2f63'}\n\n```{.sql .cell-code}\nSELECT\t* FROM \tt1;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 3 records\n\n|id | amount|\n|:--|------:|\n|1  |     10|\n|2  |     NA|\n|3  |     30|\n\n</div>\n:::\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-12_146773048e2c841c686bb0472f7c107b'}\n\n```{.sql .cell-code}\n\nSELECT AVG(amount)::numeric(10,2) \nFROM t1;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| avg|\n|---:|\n|  20|\n\n</div>\n:::\n\n\n### Torch\n\n\n::: {.cell hash='mean_cache/html/unnamed-chunk-13_ef31061c8104a2995d13c83bdaeb06a2'}\n\n```{.python .cell-code}\nimport torch\n```\n:::\n\n\n:::\n\n\n\n## Bayesian\n\n[Bayesian average](https://en.wikipedia.org/wiki/Bayesian_average); [Solving an age-old problem using Bayesian Average](https://www.codementor.io/@arpitbhayani/solving-an-age-old-problem-using-bayesian-average-15fy4ww08p); [Of bayesian average and star ratings](https://fulmicoton.com/posts/bayesian_rating/); [Bayesian Average Ratings](https://www.evanmiller.org/bayesian-average-ratings.html) ; \n\n**English**: The Bayesian average is the weighted average of a prior and the observed sample average. When would you want this? When you have strong beliefs about the true mean, or when sample size is too small to reliable calculate a mean. For example a movie rating website where a movie may have only a single 5 star rating and so would rank higher than the Godfather with over a 100 almost all 5 star ratings.\n\n**Formalization**:\n\n\n$$\n\\bar{x}=\\frac{C*m+(\\sum^{n}_{i=1}x_i)}{c+n}\n$$\n\n\n\nWhere $m$ is a prior for true mean, and $C$ is a constant representing how many elements would be necessary to reliably estimate a sample mean.\n\n**Code**\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}